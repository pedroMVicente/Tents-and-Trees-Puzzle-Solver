% ist1109852 Pedro Miguel Andrade da Costa Vicente
:- use_module(library(clpfd)). % para poder usar transpose/2
:- set_prolog_flag(answer_write_options,[max_depth(0)]). % ver listas completas
:- ["puzzlesAcampar.pl"]. % Ficheiro dado.
% Segue-se o codigo

/*Predicado vizinhanca/2
  vizinhanca((L, C), Vizinhanca) e verdadeiro quando a lista corresponde
  as posicoes adjacentes na vertical e na horizontal de posicao de
  coordenadas (L,C)*/

vizinhanca((L,C), Vizinhanca):-

    %Obtencao das coordenadas da posicao

    Lmenos1 is L-1,
    Lmais1 is L+1,
    Cmenos1 is C-1,
    Cmais1 is C+1,

    %Adicionar as posicoes a vizinhanca

    append([[(Lmenos1,C),(L,Cmenos1),
            (L, Cmais1),(Lmais1,C)]],Vizinhanca),
    !.


/*Predicado VizinhancaAlargada/2
  vizinhancaAlargada((L, C), VizinhancaAlargada) e verdadeiro quando
  Vizinhanca e a lista com as posicoes ao arredor da posicao (L,C) na
 diagonal, na vetical e na horizontal*/

vizinhancaAlargada((L,C),Vizinhanca):-

    %Obtencao das coordenadas da posicao

    Lmenos1 is L-1,
    Lmais1 is L+1,
    Cmenos1 is C-1,
    Cmais1 is C+1,

    %Adicionar as posicoes a vizinhanca

    append([[(Lmenos1,Cmenos1),(Lmenos1,C),
            (Lmenos1, Cmais1),(L,Cmenos1),
            (L,Cmais1),(Lmais1, Cmenos1),
            (Lmais1, C),(Lmais1,Cmais1)]],
           Vizinhanca),
    !.


/*Predicado todasCelulas/2

  todasCelulas(Tabuleiro, TodasCelulas) e verdadeiro quando TodasCelulas
  e uma lista com todas a posicoes do Tabuleiro*/

%Introducao do processo iterativo e de mais um argumento para a posicao
todasCelulas(Tabuleiro, TodasCelulas):-
    !,
    todasCelulas( Tabuleiro,(1,1),[], TodasCelulas).

%Base de recursao
todasCelulas([],_, TodasCelulas,TodasCelulas):-!.

%Obtencao das posicoes da mesma linha
todasCelulas([[_|R_primeira_lista]|Restantes],(Linha, Coluna),
             ListaAuxiliar, TodasCelulas):-

    %Adicionar a nova celula para a listaauxiliar
    append(ListaAuxiliar, [(Linha,Coluna)],NovoTodasCelulas),

    %Passar para a poxima celula
    Nova_coluna is Coluna +1,

    !,
    todasCelulas([R_primeira_lista|Restantes],(Linha,Nova_coluna),
                 NovoTodasCelulas,TodasCelulas).

%Mudanca para a linha posterior
todasCelulas([[]|Restantes],(Linha, _), ListaAuxiliar, TodasCelulas):-

    Nova_linha is Linha +1,

    !,
    todasCelulas(Restantes,(Nova_linha,1),ListaAuxiliar,TodasCelulas).




/*Predicado todasCelulas/3

  todasCelulas(Tabuleiro, TodasCelulas, Objecto) e verdadeiro quando
  TodasCelulas e uma lista ordenada sem elementos repetidos com todas as
  posicoes onde o Objecto esta presente no Tabuleiro*/


todasCelulas(Tabuleiro, TodasCelulas, Objecto):-

    %Determinar todas as celulas do tabuleiro
    todasCelulas(Tabuleiro, PosicoesTabuleiro),

    !,
    todasCelulas( Tabuleiro,PosicoesTabuleiro,[], TodasCelulas,
                  Objecto).


%Base de recursao
todasCelulas( [],[],TodasCelulas, TodasCelulas,_):-!.

/*Caso Objecto seja uma variavel livre, entao prentendemos determinar os
 espacos vazios*/
todasCelulas([[Primeiro|R_primeira_lista]|Restantes],
             [Posicao|R_posicoes],ListaAuxiliar,
             TodasCelulasFinal, Objecto):-

    /*Para determinarmos os espacos vazios, encontramos todas as Celulas
      em que o Primeiro elemento da lista e tambem uma variavel*/
    var(Primeiro),

    var(Objecto),

    %Adicionar a celula a uma nova lista
    append(ListaAuxiliar,[Posicao],NovoTodasCelulas),

    !,
    todasCelulas([R_primeira_lista|Restantes],R_posicoes,
                 NovoTodasCelulas,TodasCelulasFinal,Objecto).

%Obtencao das posicoes onde o objecto aparece
todasCelulas([[Primeiro|R_primeira_lista]|Restantes],
             [Posicao|R_posicoes],ListaAuxiliar,
             TodasCelulasFinal, Objecto):-

    %Verificar que o Objecto e Primeiro sao iguais
    Primeiro==Objecto,

    %Adicionar a lista a dada celula
    append(ListaAuxiliar,[Posicao],NovoTodasCelulas),

    !,
    todasCelulas([R_primeira_lista|Restantes],R_posicoes,
                 NovoTodasCelulas,TodasCelulasFinal,Objecto).

/*Se o Primeiro elemento nao e igual ao objeto pretendido, entao
  passamos para proxima posicao*/
todasCelulas([[_|R_primeira_lista]|Restantes],
            [_|R_posicoes] ,ListaAuxiliar, TodasCelulas,
             Objecto):-

    !,
    todasCelulas([R_primeira_lista|Restantes],R_posicoes,
                 ListaAuxiliar,TodasCelulas,Objecto).

%Mudanca para a linha posterior
todasCelulas([[]|Restantes],TodasPosicoes,ListaAuxiliar,
             TodasCelulas, Objecto):-
    !,
    todasCelulas(Restantes,TodasPosicoes,ListaAuxiliar,
                 TodasCelulas,Objecto).


/*Predicado auxiliar objetosNaLinhas/3

  objectoNaLinha(Linha,Objecto, N_Vezes) que e verdadeiro se N_vezes e o
  numero de vezes que o objecto aparece na lista linha*/

objectoNaLinha(Objecto,Linha,N_vezes):-

    %Obtencao de todas as celulas em que o objecto aparece
    todasCelulas([Linha],PosicoesObjecto, Objecto),

    %Determinar o comprimento da lista
    length(PosicoesObjecto, N_vezes),

    !.

/*Predicado calculaObjectosTabuleiro/4

 calculaObjectosTabuleiro(Tabuleiro, ContagemLinhas, ContagemColunas,
 Objecto) e verdade se Tabuleiro for mesmo um tabuleiro, ContagemLinhas
 for uma lista com o numero de vezes que o objecto aparece em cada
 linha do tabuleiro, ContagemColunas for uma lista com o numero de
 vezes que o objecto aparece nas colunas e objecto for mesmo um
 objecto*/

calculaObjectosTabuleiro(Tabuleiro,ContagemLinhas,
                         ContagemColunas,Objecto):-
    %Obter a transposta do tabuleiro
    transpose(Tabuleiro, TabuleiroTransposto),

    %Determinar o numero de vezes que o objecto aparece em cada linha
    maplist(objectoNaLinha(Objecto), Tabuleiro, ContagemLinhas),

    %Determinar o numero de vezes que o objecto aparece em cada linha
    maplist(objectoNaLinha(Objecto),TabuleiroTransposto, ContagemColunas),!.


/*Predicado celulaVazia/2

  Predicado(Tabuleiro, Posicao) e verdade caso a celula do tabuleiro
  esteja vazias ou tenha relva nela*/

%Caso a posicao seja vazia
celulaVazia(Tabuleiro,Posicao):-

    todasCelulas(Tabuleiro, TodasCelulasVazias, _),

    member(Posicao,TodasCelulasVazias).

%Caso a posicao seja relva
celulaVazia(Tabuleiro,Posicao):-

    todasCelulas(Tabuleiro,TodasCelulasRelva, r),

    member(Posicao, TodasCelulasRelva).

%Caso a posicao nao esteja presente no Tabuleiro
celulaVazia(Tabuleiro, Posicao):-

    todasCelulas(Tabuleiro,TodasCelulas),

    \+member(Posicao,TodasCelulas).


/*Predicado insereObjectoCelula/3

  insereObjectoCelula(Tabuleiro, TendaOuRelva, (L, C)) e verdadeiro
  se Tabuleiro e um tabuleiro e (L,C) e a posicao do tabuleiro onde
  queremos colocar uma tenda ou uma relva*/

insereObjectoCelula(Tabuleiro, TendaOuRelva, (L,C)):-

    %Obter a linha onde esta a celula
    nth1(L, Tabuleiro,Linha),

    /*Obter a celula do tabuleiro que se pretenda
     inserir relva ou uma tenda*/
    nth1(C, Linha, Celula),

    %Introducao da tenda ou relva
    Celula=TendaOuRelva,

    !.

%Caso (L,C) nao seja uma celula livre, o tabuleiro mantem-se intacto
insereObjectoCelula(_, _,_):-
    !.


/*Predicado insereObjectoEntrePosicoes/4

  insereObjectoEntrePosicoes(Tabuleiro, TendaOuRelva, (L, C1), (L, C2))
  e verdade se Tabuleiro e um Tabuleiro e (L,C1),(L,C2) sao duas
  posicoes do Tabuleiro em que pretende-se inserir entre elas(inclusive)
  o Objeto pretendido*/

insereObjectoEntrePosicoes(Tabuleiro, TendaOuRelva,
                           (L, C1), (L,C2)):-

    %Obtencao de todas Celulas do tabuleiro
    todasCelulas(Tabuleiro, TodasCelulas),

    /*Filtracao de todas as celulas que estejam entre as duas posicoes
     pretendidas*/
    findall((L,ColunaPosicao),
            (member((L,ColunaPosicao),TodasCelulas),
             between(C1,C2,ColunaPosicao)),
            TodasPosicoesFiltradas),

    %inserir o objecto pretendido nas celulas do tabuleiro
    maplist(insereObjectoCelula(Tabuleiro, TendaOuRelva),
            TodasPosicoesFiltradas),!.


/*Predicado auxiliar iguais/3

 iguais(Elemento1, Elemento2, Validacao) e verdadeiro caso o primeiro e
 o segudno elementos sejam iguais, com a constante valido, ou que ambos
 os elementos sejam diferentes com a palavra invalido*/

iguais(Elemento,Elemento,valido):-!.
iguais(Primeiro, Segundo, invalido):-Primeiro\==Segundo,!.


/*Predicado relva/1

 relva(Puzzle) e verdadeiro se todas as entradas das linhas e
 colunas tem relva cujo ja se atingiu o numero possivel de tendas nas
 linhas e nas colunas*/

%Determinar quais as linhas e as colunas que devem ser preenchidas
relva((Tabuleiro, TodasLinhas, TodasColunas)):-

    %Determinar numero de tendas em cada linha/coluna
    calculaObjectosTabuleiro(Tabuleiro,AtualTendasLinhas,
                             AtualTendasColunas,t),

    %Determinar onde e possivel aplicar o predicado
    maplist(iguais, AtualTendasLinhas, TodasLinhas,
            LinhasPreenchidas),

    maplist(iguais, AtualTendasColunas, TodasColunas,
            ColunasPreenchidas),

    /*Determinar quais os indices, ou seja, linhas e colunas em
     que se vai aplicar o predicado*/
    findall(Indice, nth1(Indice, LinhasPreenchidas, valido),
            ListaIndicesLinhas),

    findall(Indice, nth1(Indice, ColunasPreenchidas, valido),
            ListaIndicesColunas),

    %Obter o comprimento do Tabuleiro
    length(Tabuleiro, Comprimento),
    !,
    relva(Tabuleiro, ListaIndicesLinhas, ListaIndicesColunas,
          Comprimento).

%Base de recursao
relva(_,_,[],[],_):-!.

%Inserir relva nas colunas
relva(_,TabuleiroTransposto, [],
      [Indice|RestantesIndices],Comprimento):-


    insereObjectoEntrePosicoes(TabuleiroTransposto, r,
                               (Indice,1),
                               (Indice,Comprimento)),

    !,
    relva(_,TabuleiroTransposto,[],
          RestantesIndices,Comprimento).


%Obter a Transposta do tabuleiro
relva(Tabuleiro, [],ListaIndicesColunas,Comprimento):-

    transpose(Tabuleiro, TabuleiroTransposto),

    !,
    relva(Tabuleiro, TabuleiroTransposto,[],
          ListaIndicesColunas,Comprimento).


%Inserir relva nas linhas validas
relva(Tabuleiro, [Indice|RestantesIndices],
      ListaIndicesColunas,Comprimento):-

    insereObjectoEntrePosicoes(Tabuleiro, r,
                               (Indice,1),
                               (Indice,Comprimento)),
    !,
    relva(Tabuleiro, RestantesIndices,
          ListaIndicesColunas,Comprimento).


/*Predicado inacessiveis/1

  inacessiveis(Tabuleiro) e verdade se Tabuleiro e um tabuleiro que,
  apos a aplicacao do predicado, tem relva em todas as posicoes
  inacessiveis*/

inacessiveis(Tabuleiro):-

    %Obtecao a todas as celulas do tabuleiro
    todasCelulas(Tabuleiro, TodasCelulas),

    %Obtecao de todas as celulas onde estao as arvores
    todasCelulas(Tabuleiro, Arvores,a),

    %Obter as Vizinhancas das tendas e arvores
    maplist(vizinhanca,Arvores,VizinhancaArvoresListas),

    %Eliminar as sublistas
    append(VizinhancaArvoresListas, VizinhancaArvores),

    %Determinar as celulas inacessiveis
    findall(Celula,(member(Celula,TodasCelulas),
                    \+member(Celula,VizinhancaArvores)),
            Inacessiveis),

    %Inserir relva nas celulas inacessiveis
    maplist(insereObjectoCelula(Tabuleiro, r),Inacessiveis),
    !.

/*Predicado auxiliar soma/3

 soma(Elemento1,Elemento2,Soma) e verdade quando Soma e a soma
 do Elemento1 com o Elemento2*/

soma(Elemento1,Elemento2,Soma):-Soma is Elemento1+Elemento2.

/*Predicado aproveita/1

 aproveita(Puzzle) e verdade se Puzzle e um puzzle que, apos a
 aplicacao do predicado, tem tendas em todas as linhas e colunas as
 quais faltavam colocar X tendas e que tinham X posicoesLivres*/

aproveita((Tabuleiro, TendasLinhas, TendasColunas)):-

    %Determinar o numero de celulas vazias nas linhas e colunas
    calculaObjectosTabuleiro(Tabuleiro, CelulasVaziasLinhas,
                             CelulasVaziasColunas, _),

    %Determinar o numero de tendas nas linhas e nas colunas atuais
    calculaObjectosTabuleiro(Tabuleiro, TendasLinhasAtuais,
                             TendasColunasAtuais, t),

    %Obter uma lista com o numero de possiveis tendas nas linhas
    maplist(soma, CelulasVaziasLinhas,
            TendasLinhasAtuais, PossiveisTendasLinhas),

    %Obter uma lista com o numero de possiveis tendas nas colunas
    maplist(soma,CelulasVaziasColunas,
            TendasColunasAtuais, PossiveisTendasColunas),

    %Determinar onde e valido aplicar o predicado
    maplist(iguais, PossiveisTendasLinhas, TendasLinhas,
            CompletarLinhas),

    maplist(iguais, PossiveisTendasColunas, TendasColunas,
            CompletarColunas),

    /*Determinar quais os indices, ou seja, linhas e colunas em
    que se vai aplicar o predicado*/
    findall(Indice, nth1(Indice, CompletarLinhas, valido),
            ListaIndicesLinhas),

    findall(Indice, nth1(Indice, CompletarColunas, valido),
            ListaIndicesColunas),

    length(Tabuleiro,Comprimento),

    !,
    aproveita(Tabuleiro, ListaIndicesLinhas,
              ListaIndicesColunas,Comprimento).

%Base de recursao
aproveita(_,_,[],[],_):-!.

%Inserir relva nas colunas
aproveita(_,TabuleiroTransposto, [],
          [Indice|RestantesIndices],Comprimento):-

    insereObjectoEntrePosicoes(TabuleiroTransposto, t,
                               (Indice,1),
                               (Indice,Comprimento)),

    !,
    aproveita(_,TabuleiroTransposto, [], RestantesIndices,Comprimento).

%Obter a Transposta do tabuleiro
aproveita(Tabuleiro, [],ListaIndicesColunas,Comprimento):-

    transpose(Tabuleiro, TabuleiroTransposto),

    !,
    aproveita(Tabuleiro, TabuleiroTransposto,[],
              ListaIndicesColunas,Comprimento).

%Inserir relva nas linhas validas
aproveita(Tabuleiro, [Indice|RestantesIndices],
          ListaIndicesColunas,Comprimento):-

    insereObjectoEntrePosicoes(Tabuleiro, t,
                               (Indice,1),
                               (Indice,Comprimento)),

    !,
    aproveita(Tabuleiro, RestantesIndices,
              ListaIndicesColunas,Comprimento).


/*Predicado limpaVizinhancas/1

 LimpaVizinhancas(Puzzle) e verdade se apos a aplicacao do predicado
 todas as posicoes que percentem as vizinhancas das tendas estao
 preenchidas com
 relva*/

limpaVizinhancas((Tabuleiro, _,_)):-

    %Obtencao das celulas do tabuleiro
    todasCelulas(Tabuleiro, TodasCelulas),

    %Obtencao das celulas onde estao as tendas
    todasCelulas(Tabuleiro, Tendas, t),

    %Obtencao das vizinhancas das celulas com tendas
    maplist(vizinhancaAlargada, Tendas, TodasVizinhancasListas),

    %Remover as sublistas
    append(TodasVizinhancasListas, TodasVizinhancasTemporarias),

    %filtrar todas as celulas que pertencem ao tabuleiro
    findall(Posicao, (member(Posicao,TodasVizinhancasTemporarias),
                     member(Posicao, TodasCelulas)),
            TodasVizinhancasPosicoes),

    maplist(insereObjectoCelula(Tabuleiro,r), TodasVizinhancasPosicoes),
    !.


/*Predicado auxiliar filtraTendasEVazias/4

 tendasVizinhanca(TodasTendas, TodasCelulaVazias,
 Vizinhanca, VizinhancaLivres) e verdade caso VizinhancaLivres seja uma
 lista com todas as celulas que pertencem a vizinhanca e a TodasTendas
 ou a TodasCelulasVazias*/

filtraTendasEVazias(TodasTendas,TodasCelulasVazias,
                    Vizinhanca, VizinhancaLivres):-

    /*Determinar todas as celulas da vizinhanca que estejam vazias ou
    tenham tendas*/

    findall(Celula,(member(Celula,Vizinhanca),
                    (member(Celula, TodasTendas);
                     member(Celula,TodasCelulasVazias))),
            VizinhancaLivres),!.


/*Predicado unicaHipotese/1

 unicaHipotese(Puzzle) e verdade caso todas as arvores que tinham
 apenas uma celula livre na sua vizinhanca apos a aplicacao do
 predicado essa posicao fica preenchida com uma tenda*/

unicaHipotese((Tabuleiro,_,_)):-

    %Determinar as celulas onde estao as tendas
    todasCelulas(Tabuleiro, TodasTendas, t),

    %Determinar as celulas que estao vazias
    todasCelulas(Tabuleiro, TodasCelulasVazias,_),

    %Determinar as celulas onde estao as arvores
    todasCelulas(Tabuleiro, TodasArvores,a),

    %Obter as vizinhancas
    maplist(vizinhanca, TodasArvores, VizinhancasArvores),

    /*Filtrar as celulas que pertencem as vizinhancas das arvores
    Mas que nao sao arvores nem relvas*/
    maplist(filtraTendasEVazias(TodasCelulasVazias,
                                TodasTendas),
            VizinhancasArvores,
            VizinhancaArvoresLivres),

    /*Caso o comprimento da Vizinhanca filtrada seja diferente de 1
    significa que ja tem pelo menos uma tenda na sua vizinhanca ou
    mais do que uma posicao livre*/
    findall(Vizinhanca,(length(Vizinhanca,1),
                        member(Vizinhanca,VizinhancaArvoresLivres)),
            PossiveisLivresListas),

    %Remover sublistas
    append(PossiveisLivresListas, PossiveisLivres),

    %Filtrar as tendas caso ainda exista alguma
    findall(CelulaLivre,(member(CelulaLivre,PossiveisLivres),
                         \+member(CelulaLivre,TodasTendas)),
            PosicoesLivres),

    %Inserir no tabuleiro todas as tendas nas posicoes livres
    maplist(insereObjectoCelula(Tabuleiro, t), PosicoesLivres),

    !.

/*Predicado auxiliar  repetido/1

  repetido(Lista) e verdade caso a Lista tenha emlementos repetidos*/

%Base de recursao
repetido([]):-!.

%Averiguar se o primeiro elemento de uma lista esta no resto da lista
repetido([Primeiro|RLista]) :- member(Primeiro, RLista);repetido(RLista).


/*Predicado auxiliar tendasVizinhanca/2

 tenOuArvVizinhanca(LTenOuLArv, Vizinhanca, VizinhancaTendas) e verdade
 caso VizinhancaTendas seja uma lista com todas as celulas que contem
 todas as celulas que pertence ma lista LTenOuLArv e a vizinhanca
 da arvore*/

tenOuArvVizinhanca(LTenOuLArv, Vizinhanca, VizinhancaTendas):-
    findall(TendaOuArvore,(member(TendaOuArvore,LTenOuLArv),
                   member(TendaOuArvore,Vizinhanca)),
            VizinhancaTendas),
    !.


/*Predicado validaTabuleiro/2

 validaTabuleiro(LArv, LTen) e verdade caso seja possivel associar cada
 tenda de LTen a somente a uma das arvores de LArv.
 Este predicado e utilizado como predicado auxiliar para o
 predicado valida e como principal para validar a aplicacao dos diversos
 predicados no resolve sao validos*/


validaTabuleiro(LArv, LTen):-

    %Obter as vizinhancasAlargada das tendas
    maplist(vizinhancaAlargada,
            LTen, VizinhancasAlargadas),

    %Verificar se existem tendas nas vizinhancas
    maplist(tenOuArvVizinhanca(LTen),
            VizinhancasAlargadas,
            TendasInvalidas),

    append(TendasInvalidas,[]),

    %Obter vizinhancas simples das tendas
    maplist(vizinhanca,
            LTen, VizinhancasSimplesTen),

    %Verificar que nao existem tendas isoladas
    maplist(tenOuArvVizinhanca(LArv),
            VizinhancasSimplesTen,
            ArvoresNasVizinhancas),

    findall(Vizinhanca,
            (   member(Vizinhanca,
                       ArvoresNasVizinhancas),
                length(Vizinhanca,0)),
            []),

    %Obtencao de todas as vizinhancas das arvores

    maplist(vizinhanca,LArv, VizinhancasArvores),

    /*Filtrar todas as celulas de cada vizinhanca com as celulas
      onde se encontram tendas*/
    maplist(tenOuArvVizinhanca(LTen),VizinhancasArvores,
            VizinhancasComTendas),

    findall(Vizinhanca,(member(Vizinhanca,
                               VizinhancasComTendas),
                        \+length(Vizinhanca,0)),
            VizinhancasFiltradasTen),

    %Verificar vizinhancas repetidas
    repetido(VizinhancasFiltradasTen),

    /*Obtencao de todas as vizinhancas com apenas uma tenda
      na sua vizinhanca*/
    findall(Vizinhanca, (member(Vizinhanca, VizinhancasFiltradasTen),
                         length(Vizinhanca,1)),
            VizinhancasSimplesArv),

    %remover sublistas
    append(VizinhancasSimplesArv, TendasAssociadas),

    /*Encontrar todas as tendas que nao se encontram
      associadas a nenhuma arvore*/
    findall(Tenda, (member(Tenda, LTen),
                     \+member(Tenda, TendasAssociadas)),
            TendasNaoAssociadas),

    %Obtencao das vizinhancas com mais tendas
    findall(Vizinhanca, (member(Vizinhanca, VizinhancasFiltradasTen),
                         \+length(Vizinhanca,1)),
            VizinhancasDiferentes),

    /*O numero de vizinhancas em falta tem que ser igual ao numero
    de vizinhancas que tem duas tendas na sua vizinhanca*/
    length(TendasNaoAssociadas, Comprimento),
    length(VizinhancasDiferentes,Comprimento),

    !.


/*Predicado valida/2

 valida(LArv, LTen) e verdade caso LArv e LTen sao as listas com todas
 as cooredenadas em que existem arvores e tendas, respetivamente, e e
 validado caso seja verdade que e possivel estabelecer somente uma
 unica tenda para cada arvore nas suas vizinhancas*/

valida(LArv,LTen):-

    %Obtencao das vizinhancas
    maplist(vizinhanca, LArv,VizinhancasArvores),

    %Filtrar as celulas de cada vizinhanca que tenham tendas
    maplist(tenOuArvVizinhanca(LTen),VizinhancasArvores,
            VizinhancasFiltradasTen),

    %Verificar que nao existem tendas isoladas
    findall(Vizinhanca,(member(Vizinhanca,VizinhancasFiltradasTen),
                              length(Vizinhanca,0)),
            []),

    %validar o tabuleiro
    validaTabuleiro(LArv,LTen),
    !.


/*Predicado resolve/1
 resolve(Puzzle) e verdade se apos a aplicacao do predicado o mesmo
 fica resolvido*/

resolve((Tabuleiro, TendasLinhas, TendasColunas)):-

    /*Preencher as linhas com relva que ja tenham o maximo numero
    de tendas*/
    relva((Tabuleiro, TendasLinhas, TendasColunas)),


    %Preencher as posicoes inacessiveis
    inacessiveis(Tabuleiro),

    !,

    resolve((Tabuleiro, TendasLinhas, TendasColunas),[]).

%Quando o puzzle estiver resolvido
resolve((Tabuleiro, TendasLinhas, TendasColunas),_):-

    %Obtencao da lista de todas as celulas vazias to tabuleiro
    todasCelulas(Tabuleiro, CelulasVazias,_),

    /*Caso nao haja celulas vazias, entao o puzzle ja foi
    supostamente resolvido*/
    CelulasVazias==[],

    %Validar o tabuleiro
    todasCelulas(Tabuleiro,TodasTendas,t),
    todasCelulas(Tabuleiro,TodasArvores,a),
    valida(TodasArvores,TodasTendas),


    %Verificar se o numero de tendas nas colunas e linhas e valido
    calculaObjectosTabuleiro(Tabuleiro, ContagemLinhas,
                            ContagemColunas, t),

    ContagemLinhas=TendasLinhas,
    ContagemColunas=TendasColunas,
    !.

%Resolucao Do puzzle
resolve((Tabuleiro, TendasLinhas, TendasColunas),TabuleiroAnterior):-

    /*Caso o numero de celulas vazias seja diferente de 0
    entao o puzzle nao esta resolvido*/

    todasCelulas(Tabuleiro, CelulasVazias,_),

    \+length(CelulasVazias,0),

    /*Obtencao da lista de todas as celulas vazias do tabuleiro
    e do anterior*/
    todasCelulas(TabuleiroAnterior, CelulasVaziasAnteriores,_),

    %As listas de celulas vazias de cada tabuleiro deve ser diferente
    CelulasVazias\==CelulasVaziasAnteriores,

    %Caso seja diferente realiza-se uma copia do tabuleiro
    copy_term(Tabuleiro, TabuleiroCopiado),

    %Inserir tendas nas arvores com apenas uma hipotese de ligacao
    unicaHipotese((Tabuleiro, TendasLinhas, TendasColunas)),

    %Inserir relva nas posicoes da vizinhanca da tenda
    limpaVizinhancas((Tabuleiro, TendasLinhas, TendasColunas)),

    %Inserir relva nas linhas e colunas ja completas
    relva((Tabuleiro, TendasLinhas, TendasColunas)),

    %Completar as linhas com tendas
    aproveita((Tabuleiro, TendasLinhas, TendasColunas)),

    %Verificar se o tabuleiro e valido
    todasCelulas(Tabuleiro, TodasTendas,t),
    todasCelulas(Tabuleiro,TodasArvores,a),
    validaTabuleiro(TodasArvores,TodasTendas),

    %Inserir relva nas posicoes da vizinhanca da tenda
    limpaVizinhancas((Tabuleiro, TendasLinhas, TendasColunas)),

    %Inserir relva nas linhas e colunas ja completas
    relva((Tabuleiro, TendasLinhas, TendasColunas)),


    /*voltar a realisar este processo ate o tabuleiro
    ficar totalmente preenchido*/
    resolve((Tabuleiro, TendasLinhas, TendasColunas),TabuleiroCopiado).


/* Caso as estrategias nao resultem entao coloca-se uma tenda hipotetica
 na primeira celula vazia de uma dada arvore*/
resolve((Tabuleiro, TendasLinhas, TendasColunas),
        TabuleiroAnterior):-


    %Obtencao das celulas vazias
    todasCelulas(Tabuleiro, CelulasVazias,_),

    %Obtencao de todas as arvores
    member(Celula, CelulasVazias),

    %Inserir uma tenda hipotetica na primeira celula vazias
    insereObjectoCelula(Tabuleiro, t, Celula),

    %Verificar se o tabuleiro e valido
    todasCelulas(Tabuleiro, TodasTendas,t),
    todasCelulas(Tabuleiro,TodasArvores,a),
    validaTabuleiro(TodasArvores,TodasTendas),

    %Inserir relva nas posicoes da vizinhanca da tenda
    limpaVizinhancas((Tabuleiro, TendasLinhas, TendasColunas)),

    %Inserir relva nas linhas e colunas ja completas
    relva((Tabuleiro, TendasLinhas, TendasColunas)),


    resolve((Tabuleiro, TendasLinhas, TendasColunas),
            TabuleiroAnterior).













